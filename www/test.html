<!doctype html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Holovideo Viewer</title>

<style>
	#container {
		background: #000;
		width: 400px;
		height: 300px;
	}
</style>

<script type="text/javascript" src="./glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="./webgl-utils.js"></script>
<script type="text/javascript" src="./utils.js"></script>
<script type="text/javascript" src="./scene.js"></script>
<script type="text/javascript" src="./Libraries/threeJS/Three.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>

</head>

<body>
	<video id="holovideo" autoplay loop style="display:none">   
		<source src="./videos/test.mp4" type='video/mp4;'>
        Your browser doesn't appear to support the HTML5 <code>&lt;video&gt;</code> element. 
    </video>

	<div id="container">

	</div>
	
	<script type="text/javascript">

	function loadShader(url) 
	{
		var shaderSource = '';
		
		$.ajax(
		{
			url: url,
			dataType: 'text',
			success: function(results){shaderSource = results;},
			async:   false
		});
		
		return shaderSource;
	}
	
	var container;
	
	var camera, scene, renderer, composer;
	var sceneScreen, sceneScreenCamera, sceneScreenQuad;
	
	var holovideoFrame;
	
	var shaderTextureDisplay, shaderColorConvert, shaderPhaseCalculator, shaderDepthCalculator, shaderNormalCalculator, shaderFinalRender;
	var texturePhaseMap, textureDepthMap, textureNormalMap;
	
	// set the scene size
	var WIDTH = 600,
	    HEIGHT = 400;
		
	var TEXTURE_WIDTH = 512, TEXTURE_HEIGHT = 512;
	
	// set some camera attributes
	var VIEW_ANGLE = 45,
	    ASPECT = WIDTH / HEIGHT,
	    NEAR = 0.1,
	    FAR = 10000;
	
	init();
	animate();
	
	function initTextures()
	{
		var videoElement = $('#holovideo')[0];
		holovideoFrame = new THREE.Texture(videoElement);
		holovideoFrame.min_filter = THREE.LinearFilter;
		holovideoFrame.max_filter = THREE.LinearFilter;
		holovideoFrame.needsUpdate = true;
		
		//	Needed to enable floating point textures
		var gl = renderer.context;
		if (!gl.getExtension("OES_texture_float")) {
           throw("Requires OES_texture_float extension");
        }
		
		texturePhaseMap = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_HEIGHT, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat, type: THREE.FloatType});
		
		textureDepthMap = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_HEIGHT, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat, type: THREE.FloatType});
		
		textureNormalMap = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_HEIGHT, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat});
	}
	
	function initShaders()
	{
		var uniformsTextureDisplay = {
			image: {type: "t", 
					value: 0,
					//texture: holovideoFrame				
					texture: textureNormalMap
					}
		};
		
		shaderTextureDisplay = new THREE.ShaderMaterial({
			uniforms: uniformsTextureDisplay,
			vertexShader: loadShader('./shaders/TextureDisplay.vert'),
			fragmentShader: loadShader('./shaders/TextureDisplay.frag')
		});
	
		var uniformsColorConvert = {
			image: {type: "t", 
					value: 0,
					//texture: holovideoFrame						
					texture: THREE.ImageUtils.loadTexture('./images/circleF6B4.png') 
					}
		};
		
		shaderColorConvert = new THREE.ShaderMaterial({
			uniforms: uniformsColorConvert,
			vertexShader: loadShader('./shaders/colorChannelConvert.vert'),
			fragmentShader: loadShader('./shaders/colorChannelConvert.frag')
		});
		
		var uniformsPhaseCalculator = {
			holovideoFrame: {type: "t", 
							 value: 0,
							 //texture: holovideoFrame						
							 texture: THREE.ImageUtils.loadTexture('./images/circleF6B4.png') 
					},

			width: {type: "f", value: 512.0},
			depthWrite: false
		};
		
		shaderPhaseCalculator = new THREE.ShaderMaterial({
			uniforms: uniformsPhaseCalculator,
			vertexShader: loadShader('./shaders/PhaseCalculator.vert'),
			fragmentShader: loadShader('./shaders/PhaseCalculator.frag')
		});
		
		var uniformsDepthCalculator = {
			phaseMap: {type: "t", 
					   value: 0,
					   texture: texturePhaseMap	
					},

			width: {type: "f", value: 512.0},
			depthWrite: false
		};
		
		shaderDepthCalculator = new THREE.ShaderMaterial({
			uniforms: uniformsDepthCalculator,
			vertexShader: loadShader('./shaders/DepthCalculator.vert'),
			fragmentShader: loadShader('./shaders/DepthCalculator.frag')
		});
		
		var uniformsNormalCalculator = {
			depthMap: {type: "t", 
					   value: 0,
					   texture: textureDepthMap	
					},

			width: {type: "f", value: 512.0},
			height: {type: "f", value: 512.0},
			depthWrite: false
		};
		
		shaderNormalCalculator = new THREE.ShaderMaterial({
			uniforms: uniformsNormalCalculator,
			vertexShader: loadShader('./shaders/NormalCalculator.vert'),
			fragmentShader: loadShader('./shaders/NormalCalculator.frag')
		});
		
		var uniformsFinalRender = {
			depthMap: {type: "t", 
					   value: 0,
					   texture: textureDepthMap	
					},

			normalMap: {type: "t", 
					   value: 0,
					   texture: textureNormalMap	
					},
				
			holovideoFrame: {type: "t", 
							 value: 0,
							 //texture: holovideoFrame						
							 texture: THREE.ImageUtils.loadTexture('./images/circleF6B4.png') 
					},
				
			depthWrite: false
		};
		
		shaderFinalRender = new THREE.ShaderMaterial({
			uniforms: uniformsFinalRender,
			vertexShader: loadShader('./shaders/FinalRender.vert'),
			fragmentShader: loadShader('./shaders/FinalRender.frag')
		});
	}
	
	function initSceneScreen()
	{
		sceneScreenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
		sceneScreenCamera.position.z = 1;
	
		sceneScreen = new THREE.Scene();
		sceneScreenQuad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), shaderPhaseCalculator);
		sceneScreenQuad.position.z = 0;
		sceneScreen.add(sceneScreenQuad);
		sceneScreen.add(sceneScreenCamera);
	}
	
	function init()
	{
		// -----------------------------------------------------------------
		// Init renderer
		// -----------------------------------------------------------------
		$container = $('#container');
		renderer = new THREE.WebGLRenderer();
		$container.append(renderer.domElement);
		renderer.autoClear = false;

		// -----------------------------------------------------------------
		// Init textures and shaders
		// -----------------------------------------------------------------		
		initTextures();
		initShaders();
		initSceneScreen();
		
		// -----------------------------------------------------------------
		// Init camera and scene
		// -----------------------------------------------------------------	
		camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
		camera.position.z = 4;
		
		scene = new THREE.Scene();
		var width = 2, height = 2, segmentsWidth = 64, segmentsHeight = 64;
		var mesh = new THREE.Mesh(
		   new THREE.PlaneGeometry(width, height, segmentsWidth, segmentsHeight),
		   shaderFinalRender //shaderTextureDisplay
		);

		// add the mesh to the scene
		scene.add(mesh);
		scene.add(camera);
		
		// -----------------------------------------------------------------
		// Start the renderer
		// -----------------------------------------------------------------
		renderer.setSize(WIDTH, HEIGHT);
		renderer.setClearColorHex(0x000000, 1.0);		
	}
	
	function animate() 
	{
		requestAnimationFrame( animate );
	
		render();
	}	
	
	function render() 
	{
		holovideoFrame.needsUpdate = true;
		renderer.clear();
		
		// Pass 1 - Phase Calculation
		sceneScreenQuad.material = shaderPhaseCalculator;
		renderer.render(sceneScreen, sceneScreenCamera, texturePhaseMap, true);
		
		// Pass 2 - Depth Calculation
		sceneScreenQuad.material = shaderDepthCalculator;
		renderer.render(sceneScreen, sceneScreenCamera, textureDepthMap, true);
		
		// Pass 3 - Normal Calculation
		sceneScreenQuad.material = shaderNormalCalculator;
		renderer.render(sceneScreen, sceneScreenCamera, textureNormalMap, true);
		
		// Pass 4 - Final Render
		
		sceneScreenQuad.material = shaderTextureDisplay;
		//renderer.render(sceneScreen, sceneScreenCamera);
		
		renderer.render(scene, camera);
	}
</script>
	
</body></html>
