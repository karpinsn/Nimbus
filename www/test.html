<!doctype html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Nimbus</title>

<style>
	body {
		color: #ffffff;
		font-family:Monospace;
		font-size:13px;
		text-align:center;
		font-weight: bold;
		background-color: #000000;
		margin: 0px;
		overflow: hidden;
	}

	#container {
		background: #000;
	}
</style>

<script type="text/javascript" src="./Libraries/threeJS/Three.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>

</head>

<body>
	<div id="container">

	</div>
	
	<script type="text/javascript">

	function loadShader(url) 
	{
		var shaderSource = '';
		
		$.ajax(
		{
			url: url,
			dataType: 'text',
			success: function(results){shaderSource = results;},
			async:   false
		});
		
		return shaderSource;
	}
	
	function getUrlVars() 
	{
		var vars = {};
		var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
			vars[key] = value;
		});
		return vars;
	}

	
	var container;
	
	var camera, scene, renderer, composer;
	var sceneScreen, sceneScreenCamera, sceneScreenQuad;
	
	var shaderTextureDisplay, shaderTimeClipper, shaderPhaseCalculator, shaderDepthCalculator, shaderNormalCalculator, shaderFinalRender;
	var textureHoloframe, texturePhaseMap, textureDepthMap, textureNormalMap;
		
	var mouseX = 0, mouseY = 0;
	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;
		
	var TEXTURE_WIDTH = 512, TEXTURE_HEIGHT = 512;
	
	// set some camera attributes
	var VIEW_ANGLE = 45,
	    ASPECT = window.innerWidth / window.innerHeight,
	    NEAR = 1,
	    FAR = 10000;
	
	init();
	animate();
	
	function initTextures()
	{	
		//	Needed to enable floating point textures
		var gl = renderer.context;
		if (!gl.getExtension("OES_texture_float")) {
           throw("Requires OES_texture_float extension");
        }
		
		textureHoloframe = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_HEIGHT, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat});
		texturePhaseMap = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_HEIGHT, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat, type: THREE.FloatType});
		textureDepthMap = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_HEIGHT, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat, type: THREE.FloatType});
		textureNormalMap = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_HEIGHT, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat});
	}
	
	function initShaders()
	{
		var uniformsTextureDisplay = {
			image: {type: "t", 
					value: 0,
					//texture: textureNormalMap
					texture: textureHoloframe
					//texture: THREE.ImageUtils.loadTexture('./images/MegaFrame.png')
					}
		};
		
		shaderTextureDisplay = new THREE.ShaderMaterial({
			uniforms: uniformsTextureDisplay,
			vertexShader: loadShader('./shaders/TextureDisplay.vert'),
			fragmentShader: loadShader('./shaders/TextureDisplay.frag')
		});
		
		//	'./images/MegaFrame.png'
		var data = getUrlVars()["data"];
		
		var uniformsTimeClipper = {
			textureOverTime: {type: "t", 
							 value: 0,		
							 texture: THREE.ImageUtils.loadTexture(data)
					},

			deltaTime: 			{type: "f", value: 0.2},
			framesPerSecond: 	{type: "f", value: 30.0},
			cols: 				{type: "f", value: 8.0},
			rows: 				{type: "f", value: 8.0},
			depthWrite: false
		};
		
		shaderTimeClipper = new THREE.ShaderMaterial({
			uniforms: uniformsTimeClipper,
			vertexShader: loadShader('./shaders/TimeClipper.vert'),
			fragmentShader: loadShader('./shaders/TimeClipper.frag')
		});
		
		var uniformsPhaseCalculator = {
			holovideoFrame: {type: "t", 
							 value: 0,
							 texture: textureHoloframe						
							 //texture: THREE.ImageUtils.loadTexture('./images/Amy.png') 
							 //texture: THREE.ImageUtils.loadTexture('./images/out.png') 
					},

			width: {type: "f", value: 512.0},
			depthWrite: false
		};
		
		shaderPhaseCalculator = new THREE.ShaderMaterial({
			uniforms: uniformsPhaseCalculator,
			vertexShader: loadShader('./shaders/PhaseCalculator.vert'),
			fragmentShader: loadShader('./shaders/PhaseCalculator.frag')
		});
		
		var uniformsDepthCalculator = {
			phaseMap: {type: "t", 
					   value: 0,
					   texture: texturePhaseMap	
					},

			width: {type: "f", value: 512.0},
			depthWrite: false
		};
		
		shaderDepthCalculator = new THREE.ShaderMaterial({
			uniforms: uniformsDepthCalculator,
			vertexShader: loadShader('./shaders/DepthCalculator.vert'),
			fragmentShader: loadShader('./shaders/DepthCalculator.frag')
		});
		
		var uniformsNormalCalculator = {
			depthMap: {type: "t", 
					   value: 0,
					   texture: textureDepthMap	
					},

			width: {type: "f", value: 512.0},
			height: {type: "f", value: 512.0},
			depthWrite: false
		};
		
		shaderNormalCalculator = new THREE.ShaderMaterial({
			uniforms: uniformsNormalCalculator,
			vertexShader: loadShader('./shaders/NormalCalculator.vert'),
			fragmentShader: loadShader('./shaders/NormalCalculator.frag')
		});
		
		var uniformsFinalRender = {
			depthMap: {type: "t", 
					   value: 0,
					   texture: textureDepthMap	
					},

			normalMap: {type: "t", 
					   value: 1,
					   texture: textureNormalMap	
					},
				
			holovideoFrame: {type: "t", 
							 value: 2,
							 //texture: holovideoFrame						
							 texture: THREE.ImageUtils.loadTexture('./images/0000.png') 
					},
				
			depthWrite: false
		};
		
		shaderFinalRender = new THREE.ShaderMaterial({
			uniforms: uniformsFinalRender,
			vertexShader: loadShader('./shaders/FinalRender.vert'),
			fragmentShader: loadShader('./shaders/FinalRender.frag')
		});
	}
	
	function initSceneScreen()
	{
		sceneScreenCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);
		sceneScreenCamera.position.z = 1;
	
		sceneScreen = new THREE.Scene();
		sceneScreenPlane = new THREE.PlaneGeometry(2, 2, 1, 1);
		sceneScreenQuad = new THREE.Mesh(sceneScreenPlane, shaderPhaseCalculator);
		sceneScreenQuad.doubleSided = true;
		sceneScreenQuad.scale.y = -1;
		
		
		sceneScreen.add(sceneScreenQuad);
		sceneScreen.add(sceneScreenCamera);
	}
	
	function init()
	{
		// -----------------------------------------------------------------
		// Init renderer
		// -----------------------------------------------------------------
		$container = $('#container');
		renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setClearColorHex(0x000000, 1.0);	
		renderer.autoClear = false;
		$container.append(renderer.domElement);
		
		//	Events
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		window.addEventListener( 'resize', onWindowResize, false );
		
		// -----------------------------------------------------------------
		// Init textures and shaders
		// -----------------------------------------------------------------		
		initTextures();
		initShaders();
		initSceneScreen();
		
		// -----------------------------------------------------------------
		// Init camera and scene
		// -----------------------------------------------------------------	
		camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
		camera.position.z = 4;
		
		scene = new THREE.Scene();
		var width = 2, height = 2, segmentsWidth = 256, segmentsHeight = 256;
		var mesh = new THREE.Mesh(
		   new THREE.PlaneGeometry(width, height, segmentsWidth, segmentsHeight),
		   shaderFinalRender 
		   //shaderTextureDisplay
		);

		// add the mesh to the scene
		scene.add(mesh);
		scene.add(camera);
		
		startTime = new Date().getTime();	
	}
	
	function onWindowResize( event ) 
	{
		renderer.setSize( window.innerWidth, window.innerHeight );

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
	}
	
	function onDocumentMouseMove(event) {

		mouseX = ( event.clientX - windowHalfX ) * 0.01;
		mouseY = ( event.clientY - windowHalfY ) * 0.01;

	}
	
	function animate() 
	{
		requestAnimationFrame( animate );
	
		render();
	}	
	
	var startTime;
	
	function render() 
	{
		// Adjust camera
		camera.position.x += ( mouseX - camera.position.x ) * 0.05;
		camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
		
		camera.position.x = camera.position.x > 5.0 ? 5.0 : camera.position.x;
		camera.position.x = camera.position.x < -5.0 ? -5.0 : camera.position.x;
		
		camera.position.y = camera.position.y > 3.0 ? 3.0 : camera.position.y;
		camera.position.y = camera.position.y < -3.0 ? -3.0 : camera.position.y;
		
		camera.lookAt( scene.position );
		//camera.up.set(0,-1,0);
	
		renderer.clear();
		
		shaderTimeClipper.uniforms.deltaTime.value = new Date().getTime() - startTime;
		
		// Pass 0 - Time Clipping
		sceneScreenQuad.material = shaderTimeClipper;
		renderer.render(sceneScreen, sceneScreenCamera, textureHoloframe, true);
		
		// Pass 1 - Phase Calculation
		sceneScreenQuad.material = shaderPhaseCalculator;
		renderer.render(sceneScreen, sceneScreenCamera, texturePhaseMap, true);
		
		// Pass 2 - Depth Calculation
		sceneScreenQuad.material = shaderDepthCalculator;
		renderer.render(sceneScreen, sceneScreenCamera, textureDepthMap, true);
		
		// Pass 3 - Normal Calculation
		sceneScreenQuad.material = shaderNormalCalculator;
		renderer.render(sceneScreen, sceneScreenCamera, textureNormalMap, true);
		
		// Pass 4 - Final Render
		
		sceneScreenQuad.material = shaderTextureDisplay;
		//renderer.render(sceneScreen, sceneScreenCamera);
		
		renderer.render(scene, camera);
	}
</script>
	
</body></html>
